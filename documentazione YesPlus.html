<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentazione Tecnica - Progetto YesPlus</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            scroll-behavior: smooth;
        }
        .prose h1, .prose h2, .prose h3, .prose h4 {
            scroll-margin-top: 80px;
        }
        .sidebar {
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            width: 280px;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #e2e8f0;
            background-color: #f8fafc;
        }
        .main-content {
            margin-left: 300px;
            padding: 2rem;
        }
        .sidebar a {
            display: block;
            padding: 8px 12px;
            border-radius: 6px;
            transition: background-color 0.3s;
            color: #475569;
            font-size: 0.95rem;
        }
        .sidebar a.sub-link {
            padding-left: 24px;
            font-size: 0.9rem;
        }
        .sidebar a:hover {
            background-color: #f1f5f9;
        }
        .sidebar a.active {
            background-color: #e0f2fe;
            color: #0c4a6e;
            font-weight: 600;
        }
        .sidebar h3 {
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 0.9rem;
            font-weight: 700;
            color: #1e293b;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
         pre code.hljs{display:block;overflow-x:auto;padding:1em; border-radius: 8px;}code.hljs{padding:3px 5px}.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61afef}.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#e6c07b}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}
    </style>
</head>
<body class="bg-slate-50 text-slate-800">

    <aside class="sidebar">
        <h2 class="text-xl font-bold mb-6 text-slate-900">Documentazione YesPlus</h2>
        <nav id="sidebar-nav">
            <h3>Panoramica</h3>
            <a href="#overview" class="active">Architettura Generale</a>
            
            <h3>Struttura dei File</h3>
            <a href="#file-structure">File di Progetto</a>

            <h3>Database</h3>
            <a href="#db-structure">Introduzione</a>
            <a href="#db-central" class="sub-link">Database Centrale (MSSQL)</a>
            <a href="#db-local" class="sub-link">Database Locale (SQLite)</a>

            <h3>Client (Flutter)</h3>
            <a href="#client-intro">Introduzione e Setup</a>
            <a href="#client-arch" class="sub-link">Architettura Interna</a>
            <a href="#client-controllers" class="sub-link">Analisi Controller Chiave</a>
            <a href="#client-flows" class="sub-link">Flussi di Lavoro</a>
            
            <h3>Server (Node.js)</h3>
            <a href="#server-intro">Introduzione</a>
            <a href="#server-api" class="sub-link">Server API (Express)</a>
            <a href="#server-websocket" class="sub-link">Server WebSocket (Socket.IO)</a>

            <h3>Appendice</h3>
            <a href="#dev-guide">Guida Sviluppi Futuri</a>
        </nav>
    </aside>

    <main class="main-content">
        <div class="prose max-w-none prose-slate">
            <section id="overview">
                <h1>1. Panoramica Generale e Architettura</h1>
                <h3>Introduzione</h3>
                <p><strong>YesPlus</strong> è un'applicazione gestionale per tablet, sviluppata in Flutter, destinata alla forza vendita (agenti). Il suo scopo principale è permettere la gestione completa del ciclo di vendita in mobilità, con un'architettura robusta progettata per funzionare in modo efficiente anche in assenza di connessione a Internet (<strong>offline-first</strong>).</p>
                <p>Il sistema si compone di quattro elementi principali che lavorano in sinergia per garantire coerenza e affidabilità dei dati.</p>
                
                <h3 id="tech-stack">Stack Tecnologico</h3>
                <ul>
                    <li><strong>Client Mobile:</strong> Flutter con GetX per lo State Management.</li>
                    <li><strong>Database Locale:</strong> SQLite per la persistenza dei dati offline.</li>
                    <li><strong>Backend:</strong> Architettura a due server basata su Node.js.</li>
                    <li><strong>Server API:</strong> Express.js per la sincronizzazione massiva.</li>
                    <li><strong>Server Real-time:</strong> Socket.IO per la comunicazione bidirezionale.</li>
                    <li><strong>Database Centrale:</strong> Microsoft SQL Server (MSSQL).</li>
                </ul>

                <h3>Diagramma Architetturale</h3>
                <p>Il diagramma seguente illustra l'interazione tra i componenti del sistema:</p>
                <div class="mermaid bg-slate-100 p-4 rounded-lg">
                graph TD
                    A[Client Flutter] -- Richieste Offline/Online --> B((Server WebSocket));
                    B -- Operazioni Transazionali --> D[(DB MSSQL)];
                    A -- Sincronizzazione Massiva Iniziale --> C((Server API));
                    C -- Dati in Streaming --> A;
                    D -- DB Triggers & Stored Proc --> C;
                    C -- Notifica di Aggiornamento --> B;
                    B -- Aggiornamenti Real-time --> A;
                </div>
            </section>

            <hr class="my-12">

            <section id="file-structure">
                <h1>2. Struttura dei File di Progetto</h1>
                <p>Comprendere la struttura dei file è il primo passo per orientarsi nel progetto.</p>

                <h3>Progetto Flutter (Client)</h3>
                <p>La logica è suddivisa principalmente tra controller, modelli e viste (pagine).</p>
                <ul>
                    <li><code>lib/main.dart</code>: Punto di ingresso dell'applicazione. Gestisce l'inizializzazione e la configurazione dei "flavors".</li>
                    <li><code>lib/database/db_helper.dart</code>: File cruciale che definisce l'intero schema del database SQLite locale e fornisce i metodi per interagire con esso.</li>
                    <li><code>lib/controllers/</code>: Contiene la logica di business.
                        <ul>
                            <li><code>ordine_controller.dart</code> & <code>incassi_controller.dart</code>: Gestiscono la creazione atomica di ordini e pagamenti.</li>
                            <li><code>controller_soket.dart</code>: Gestisce tutta la comunicazione WebSocket, la coda di messaggi offline e la logica di sincronizzazione.</li>
                            <li><code>connessione_controller.dart</code>: Gestisce la sincronizzazione iniziale dei dati dal Server API.</li>
                            <li>Altri controller (<code>clienti</code>, <code>documenti</code>, etc.) gestiscono lo stato delle rispettive sezioni dell'app.</li>
                        </ul>
                    </li>
                    <li><code>lib/models/</code>: Contiene le classi Dart che modellano i dati (es. `testataordine.dart`, `righeOrdine.dart`).</li>
                    <li><code>lib/pages/</code>: Contiene i widget che compongono le schermate dell'applicazione (es. `home.dart`, `ordine.dart`).</li>
                </ul>

                <h3>Progetto Server API</h3>
                <ul>
                    <li><code>server.js</code>: File principale che avvia il server Express.</li>
                    <li><code>routes/apiRoutes.js</code>: Definisce tutte le rotte (endpoint) dell'API.</li>
                    <li><code>controllers/initdDbClient.js</code>: Contiene la logica per servire i dati in streaming per la sincronizzazione.</li>
                    <li><code>controllers/infoInitDB.js</code>: Contiene la logica per fornire al client le informazioni sul numero di record da scaricare.</li>
                    <li><code>controllers/invioDaDB.js</code>: Contiene l'endpoint <code>/trigger</code> che riceve le notifiche dal database e le inoltra al server WebSocket.</li>
                </ul>

                <h3>Progetto Server WebSocket</h3>
                 <ul>
                    <li><code>server.js</code>: L'unico file principale che avvia il server Socket.IO e contiene tutta la logica per la gestione degli eventi, delle connessioni e delle transazioni sul database.</li>
                </ul>
            </section>

            <hr class="my-12">

            <section id="db-structure">
                <h1>3. Struttura e Logica dei Database</h1>
                <p>L'architettura dati del progetto è duale: un database centrale (fonte della verità) e un database locale su ogni dispositivo, che ne è una replica parziale ottimizzata per l'uso offline.</p>

                <h2 id="db-central">Database Centrale (MSSQL)</h2>
                <p>Il database centrale è il cuore del sistema. Per permettere l'integrazione con l'app mobile, sono state introdotte tabelle di supporto, trigger e stored procedure.</p>
                
                <h3>Abilitazione Funzionalità Avanzate</h3>
                <p>È necessario abilitare le `Ole Automation Procedures` per permettere ai trigger di effettuare chiamate HTTP verso il Server API.</p>
                <pre><code class="sql">
sp_configure 'show advanced options', 1;
GO
RECONFIGURE;
GO
sp_configure 'Ole Automation Procedures', 1;
GO
RECONFIGURE;
GO
                </code></pre>

                <h3>Tabelle di Supporto</h3>
                <p>Queste tabelle gestiscono la comunicazione, la sincronizzazione e il logging.</p>
                <div class="overflow-x-auto">
                    <table class="w-full text-sm">
                        <thead class="bg-slate-100">
                            <tr><th class="p-2 text-left">Tabella</th><th class="p-2 text-left">Scopo</th></tr>
                        </thead>
                        <tbody>
                            <tr class="border-b"><td class="p-2 font-mono">Z_APP_dispositivi</td><td class="p-2">Associa l'IMEI del dispositivo ai parametri di configurazione (agente, tipi documento, ecc.) e ne traccia lo stato di connessione.</td></tr>
                            <tr class="border-b"><td class="p-2 font-mono">Z_APP_aggiorna_dispositivi</td><td class="p-2">Tabella di "staging" dove i trigger del DB inseriscono i messaggi di aggiornamento prima che vengano smistati ai client.</td></tr>
                            <tr class="border-b"><td class="p-2 font-mono">Z_APP_AG_DI</td><td class="p-2">Tabella di relazione che mappa ogni messaggio di aggiornamento (`ZAPPAD_ID`) ai dispositivi che devono riceverlo (`ZAPPD_ID`), gestendone lo stato di invio.</td></tr>
                             <tr class="border-b"><td class="p-2 font-mono">Z_PrezziTV</td><td class="p-2">Contiene i listini prezzi e gli sconti. Viene popolata da una stored procedure schedulata (`Z_AggiornaPrzTV`).</td></tr>
                            <tr class="border-b"><td class="p-2 font-mono">Z_APP_Info</td><td class="p-2">Contiene configurazioni globali, come l'URL del Server API da chiamare.</td></tr>
                            <tr class="border-b"><td class="p-2 font-mono">Z_APP_LOG</td><td class="p-2">Tabella per il logging delle operazioni eseguite da trigger e procedure.</td></tr>
                            <tr class="border-b"><td class="p-2 font-mono">Z_APP_Messaggi</td><td class="p-2">Tabella di fallback in cui vengono salvati i messaggi che i trigger non riescono a inviare al Server API.</td></tr>
                        </tbody>
                    </table>
                </div>

                <h3>Modifiche alle Tabelle Esistenti</h3>
                <p>Per permettere la sincronizzazione bidirezionale, a diverse tabelle documentali è stata aggiunta una colonna `_APP_ID` (es. `OCAN_APP_ID`). Questo campo è fondamentale per collegare un record creato offline al suo corrispettivo sul server.</p>
                <pre><code class="sql">
ALTER TABLE OC_Anag ADD OCAN_APP_ID VARCHAR(50);
ALTER TABLE OC_Artic ADD OCAR_APP_ID VARCHAR(50);
-- e altre tabelle (FT_Anag, BL_Anag, etc.)
                </code></pre>

                <h3>Trigger e Stored Procedure</h3>
                <p>Il file `modifiche_database.md` contiene il codice SQL completo per creare tutti i trigger (es. `Z_APP_TR_OC_Anag`) e le stored procedure (es. `Z_APP_OC_Anag`) necessari. I trigger si attivano dopo operazioni di `INSERT`, `UPDATE` o `DELETE` sulle tabelle principali e chiamano il Server API per notificare i client.</p>

                <h2 id="db-local">Database Locale (SQLite)</h2>
                <p>Il database locale, definito in `db_helper.dart`, è una replica parziale del database centrale. Presenta alcune differenze chiave per la gestione offline:</p>
                <ul>
                    <li><strong>`sync_status` in `OC_Anag`:</strong> Colonna cruciale che traccia lo stato di ogni ordine: `0` (Locale), `1` (Inviato), `2` (Sincronizzato).</li>
                    <li><strong>ID Locali vs ID Server:</strong> Per evitare conflitti, le tabelle come `OC_Artic` usano una chiave primaria locale autoincrementata (`ocar_locale_id`) e una colonna separata (`OCAR_ID`) che verrà popolata con l'ID del server dopo la sincronizzazione.</li>
                    <li><strong>`MessagesToSend`:</strong> Tabella di coda per tutte le operazioni create offline.</li>
                </ul>
            </section>

            <hr class="my-12">
            
            <section id="client-intro">
                <h1>4. Documentazione Dettagliata Lato Client (Flutter)</h1>
                <p>L'applicazione Flutter è un client robusto che gestisce dati e logica di business in locale, sincronizzandosi in modo intelligente con il backend.</p>
                
                <h2 id="client-setup">Setup Ambiente</h2>
                <p>Per avviare il progetto:</p>
                <ol>
                    <li>Assicurarsi di avere l'SDK di Flutter installato.</li>
                    <li>Eseguire `flutter pub get`.</li>
                    <li>L'app utilizza i "flavors". Per avviare una build, usare `flutter run --flavor [nome_flavor]`.</li>
                    <li>Al primo avvio, configurare i server e l'IMEI in "Parametri" ed eseguire la sincronizzazione da "Connessioni".</li>
                </ol>

                <h2 id="client-arch">Architettura Interna</h2>
                <h3>State Management (GetX)</h3>
                <p>Il package `get` è usato per state management (`.obs`), dependency injection (`Get.put/find`) e navigazione (`Get.to`).</p>
                
                <h3 id="client-controllers">Analisi dei Controller Chiave</h3>
                 <ul>
                    <li><strong>`WebSocketController`</strong>: È il cuore della comunicazione. Gestisce la connessione, la disconnessione e l'ascolto degli eventi dal server. I suoi metodi più importanti sono:
                        <ul>
                            <li><code>sendMessage</code>: Invia un messaggio al server se online, altrimenti lo salva nella coda locale. Gestisce la logica di `Completer` per notificare il chiamante dell'esito.</li>
                            <li><code>sendPendingMessages</code>: Si attiva alla connessione e invia tutti i messaggi salvati in locale, garantendo che nessuna operazione offline vada persa.</li>
                             <li><code>_checkPendingSyncs</code>: Gestisce i casi in cui l'app si chiude dopo un invio ma prima di una conferma, chiedendo al server lo stato degli ordini "in sospeso".</li>
                        </ul>
                    </li>
                     <li><strong>`OrdineController` e `IncassiController`</strong>: Contengono la UI logic. I metodi <code>salvaOrdine</code> e <code>paga</code> hanno il compito di raccogliere i dati dall'interfaccia, costruire l'oggetto JSON atomico (`INSERT_FULL_ORDER` o `INSERT_FULL_PAYMENT`) e passarlo al `WebSocketController` per l'invio.</li>
                </ul>

                <h2 id="client-flows">Flussi di Lavoro Chiave</h2>
                <h3>Flusso di Creazione Ordine (Atomico)</h3>
                <p>Il processo di creazione di un ordine è stato refattorizzato per essere completamente atomico e resiliente. Il diagramma illustra il flusso:</p>
                <div class="mermaid bg-slate-100 p-4 rounded-lg">
                sequenceDiagram
                    participant Utente
                    participant OrdineController
                    participant DatabaseHelper
                    participant WebSocketController
                    participant Server

                    Utente->>OrdineController: Salva Ordine
                    activate OrdineController
                    OrdineController->>DatabaseHelper: Salva ordine localmente (sync_status=0)
                    activate DatabaseHelper
                    DatabaseHelper-->>OrdineController: OK
                    deactivate DatabaseHelper
                    OrdineController->>OrdineController: Costruisce un unico JSON (INSERT_FULL_ORDER)
                    OrdineController->>WebSocketController: sendMessage(json)
                    activate WebSocketController
                    WebSocketController->>DatabaseHelper: updateOrderStatus(sync_status=1)
                    WebSocketController-->>Server: Invia messaggio atomico
                    activate Server
                    Server-->>WebSocketController: Riceve risposta con ID permanenti
                    deactivate Server
                    WebSocketController->>DatabaseHelper: updateOrderAsSynced(sync_status=2, ids)
                    activate DatabaseHelper
                    DatabaseHelper-->>WebSocketController: OK
                    deactivate DatabaseHelper
                    WebSocketController-->>OrdineController: OK (tramite listener)
                    deactivate WebSocketController
                    OrdineController-->>Utente: Mostra notifica successo (tramite listener)
                    deactivate OrdineController
                </div>

                <h3>Logica di Sincronizzazione Offline</h3>
                <p>La robustezza del sistema si basa su un meccanismo di sincronizzazione gestito dal `WebSocketController`:</p>
                <ul>
                    <li><strong>`sendPendingMessages()`:</strong> Alla riconnessione, questa funzione legge tutti i messaggi dalla tabella `MessagesToSend` e li invia uno per uno al server. Se un invio ha successo, il messaggio viene rimosso dalla coda locale.</li>
                    <li><strong>`_checkPendingSyncs()`:</strong> Per gestire il caso in cui l'app si chiude dopo aver inviato un ordine ma prima di ricevere la conferma, questa funzione (attivata alla connessione) cerca tutti gli ordini con `sync_status = 1` e chiede al server il loro stato, allineando i dati o reinviando l'ordine se necessario.</li>
                </ul>
            </section>
            
            <hr class="my-12">

            <section id="server-intro">
                <h1>5. Documentazione Dettagliata Lato Server (Node.js)</h1>
                <p>Il backend è diviso in due servizi Node.js, ciascuno con una responsabilità specifica.</p>
                
                <h2 id="server-api">Server API (Express.js)</h2>
                <ul>
                    <li><strong>Ruolo:</strong> Gestire la <strong>sincronizzazione iniziale</strong> (bootstrap) dei dati.</li>
                    <li><strong>Streaming:</strong> Utilizza lo streaming per inviare grandi volumi di dati in modo efficiente.</li>
                    <li><strong>Integrazione con DB Trigger:</strong> L'endpoint `/trigger` in `invioDaDB.js` riceve le notifiche dal DB e le inoltra al Server WebSocket.</li>
                </ul>

                <h2 id="server-websocket">Server WebSocket (Socket.IO)</h2>
                <ul>
                    <li><strong>Ruolo:</strong> Gestire la comunicazione real-time e le operazioni transazionali.</li>
                    <li><strong>Eventi Socket.IO:</strong> Gestisce eventi come `sendIMEI`, `messaggio`, `sync_check` per orchestrare la comunicazione.</li>
                    <li><strong>Logica Transazionale:</strong> Le funzioni `handleInsertFullOrder` e `handleInsertFullPayment` sono il cuore della robustezza del backend. Utilizzano le transazioni di `mssql` (`transaction.begin()`, `commit()`, `rollback()`) per garantire che un'operazione complessa venga inserita completamente o per niente.</li>
                </ul>

                <pre><code class="javascript">
// Esempio di logica transazionale in handleInsertFullPayment (server.js)
async function handleInsertFullPayment(paymentData) {
  const transaction = new sql.Transaction(pool);
  try {
    await transaction.begin();
    // 1. Crea la testata del pagamento (PF_Anag)
    const anagResult = await anagRequest.query(...);
    const newPfanId = anagResult.recordset[0].ID;

    // 2. Distribuisci l'importo sulle partite selezionate
    for (const capaId of invoiceIds) {
      // 2a. Inserisci il dettaglio del pagamento (PF_Dett)
      await insertDettRequest.query(...);
      // 2b. Aggiorna il residuo della partita (CA_Partite)
      await updatePartitaRequest.query(...);
    }
    
    // 3. Se tutto è andato bene, conferma la transazione
    await transaction.commit();
    
  } catch (err) {
    // Se qualcosa va storto, annulla tutto
    await transaction.rollback();
    throw err;
  }
}
                </code></pre>
            </section>

            <hr class="my-12">

            <section id="dev-guide">
                <h1>6. Appendice: Guida per Sviluppi Futuri</h1>
                
                <h3>Come Aggiungere un Nuovo Campo a un Ordine</h3>
                <p>Seguire questi passaggi per aggiungere, ad esempio, un campo `note_trasporto` a un ordine.</p>
                <ol>
                    <li><strong>DB Centrale (MSSQL):</strong> Aggiungere la colonna `OCAN_NoteTrasporto` alla tabella `OC_Anag`.</li>
                    <li><strong>DB Locale (SQLite):</strong> Aggiungere la colonna `OCAN_NoteTrasporto` alla definizione della tabella `OC_Anag` in `db_helper.dart`.</li>
                    <li><strong>Modello Dati (Flutter):</strong> Aggiungere il campo `ocanNoteTrasporto` alla classe `TestataOrdine` in `testataordine.dart` (incluso `fromJson` e `toJson`).</li>
                    <li><strong>UI (Flutter):</strong> Aggiungere un `TextField` in `ordine.dart` per l'input utente.</li>
                    <li><strong>Controller (Flutter):</strong> Nel `OrdineController`, nel metodo `salvaOrdine`, assicurarsi che il nuovo campo venga incluso nel `TestataOrdine` e nel JSON inviato al server.</li>
                    <li><strong>Server (Node.js):</strong> Nella funzione `handleInsertFullOrder` in `server.js`, aggiungere il nuovo campo sia alla dichiarazione dei parametri (`headerRequest.input(...)`) sia alla query `INSERT INTO OC_Anag`.</li>
                </ol>

                 <h3>Come Sincronizzare una Nuova Tabella</h3>
                 <ol>
                    <li><strong>DB Locale (SQLite):</strong> Aggiungere la `CREATE TABLE` per la nuova tabella in `db_helper.dart`.</li>
                    <li><strong>Modello Dati (Flutter):</strong> Creare la classe modello corrispondente in `lib/models/`.</li>
                    <li><strong>Server API (Node.js):</strong>
                        <ul>
                            <li>In `infoInitDB.js`, creare un nuovo endpoint (es. `/numNuovaTabella`) che esegua una `SELECT COUNT(*)` per dire al client quanti record scaricare.</li>
                            <li>In `initdDbClient.js`, creare un nuovo endpoint (es. `/syncNuovaTabella`) che esegua la `SELECT *` e serva i dati in streaming.</li>
                             <li>In `apiRoutes.js`, registrare i nuovi endpoint.</li>
                        </ul>
                    </li>
                     <li><strong>Controller (Flutter):</strong> In `connessione_controller.dart`, aggiungere la logica per chiamare i nuovi endpoint e popolare la nuova tabella locale, simile a come viene fatto per le altre tabelle.</li>
                 </ol>
            </section>
        </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            hljs.highlightAll();
            mermaid.initialize({ startOnLoad: true });

            const sections = document.querySelectorAll('section[id], h2[id], h3[id]');
            const navLinks = document.querySelectorAll('#sidebar-nav a');

            const observer = new IntersectionObserver((entries) => {
                let bestVisibleLink = null;
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const link = document.querySelector(`#sidebar-nav a[href="#${entry.target.id}"]`);
                        if (link) {
                            if (bestVisibleLink === null) {
                                bestVisibleLink = link;
                            }
                        }
                    }
                });
                
                if (bestVisibleLink) {
                     navLinks.forEach(link => link.classList.remove('active'));
                     bestVisibleLink.classList.add('active');
                }

            }, { threshold: 0.5, rootMargin: "0px 0px -40% 0px" });

            sections.forEach(section => {
                observer.observe(section);
            });
        });
    </script>
</body>
</html>

